const htmlLoader = require('@neutrinojs/html-loader');
const styleLoader = require('@neutrinojs/style-loader');
const fontLoader = require('@neutrinojs/font-loader');
const imageLoader = require('@neutrinojs/image-loader');
const compileLoader = require('@neutrinojs/compile-loader');
const env = require('@neutrinojs/env');
const hot = require('@neutrinojs/hot');
const htmlTemplate = require('@neutrinojs/html-template');
const clean = require('@neutrinojs/clean');
const styleMinify = require('@neutrinojs/style-minify');
const loaderMerge = require('@neutrinojs/loader-merge');
const devServer = require('@neutrinojs/dev-server');
const { join } = require('path');
const { resolve } = require('url');
const merge = require('deepmerge');
const HtmlWebpackIncludeSiblingChunksPlugin = require('html-webpack-include-sibling-chunks-plugin');
const ManifestPlugin = require('webpack-manifest-plugin');

const MODULES = join(__dirname, 'node_modules');

module.exports = (neutrino, opts = {}) => {
  const publicPath = opts.publicPath || './';
  const options = merge({
    publicPath,
    env: [],
    hot: true,
    hotEntries: [],
    html: {},
    devServer: {
      hot: opts.hot !== false,
      publicPath: resolve('/', publicPath)
    },
    style: {
      hot: opts.hot !== false,
      extract: process.env.NODE_ENV === 'production'
    },
    manifest: opts.html === false ? {} : false,
    clean: opts.clean !== false && {
      paths: [neutrino.options.output]
    },
    minify: {
      source: process.env.NODE_ENV === 'production',
      style: {}
    },
    babel: {},
    targets: {},
    font: {},
    image: {}
  }, opts);

  if ('babel' in options.minify) {
    throw new Error('The minify.babel option has been removed. See the web preset docs for how to customise source minification.');
  }

  if ('image' in options.minify) {
    throw new Error('The minify.image option has been removed. To enable image minification use the @neutrinojs/image-minify preset.');
  }

  if (typeof options.devServer.proxy === 'string') {
    options.devServer.proxy = {
      '**': {
        target: options.devServer.proxy,
        changeOrigin: true,
        headers: {
          'X-Dev-Server-Proxy': options.devServer.proxy
        }
      }
    };
  }

  if (!options.targets.node && !options.targets.browsers) {
    options.targets.browsers = [
      'last 2 Chrome versions',
      'last 2 Firefox versions',
      'last 2 Edge versions',
      'last 2 Opera versions',
      'last 2 Safari versions',
      'last 2 iOS versions'
    ];
  }

  Object.assign(options, {
    style: options.style && merge(options.style, {
      extract: options.style.extract === true ? {} : options.style.extract
    }),
    minify: options.minify && merge(options.minify, {
      style: options.minify.style === true ? {} : options.minify.style
    }),
    babel: compileLoader.merge({
      plugins: [
        require.resolve('babel-plugin-syntax-dynamic-import')
      ],
      presets: [
        [require.resolve('babel-preset-env'), {
          debug: neutrino.options.debug,
          modules: false,
          useBuiltIns: true,
          targets: options.targets
        }]
      ]
    }, options.babel)
  });

  if (options.env.length) {
    neutrino.use(env, options.env);
  }

  neutrino.use(htmlLoader);
  neutrino.use(compileLoader, {
    include: [
      neutrino.options.source,
      neutrino.options.tests
    ],
    babel: options.babel
  });

  neutrino.config
    // This must be before html-webpack-plugin (but with variable main names it's a pain to use .before()).
    // TODO: Remove this plugin once html-webpack-plugin fully supports webpack 4's splitChunks
    // https://github.com/jantimon/html-webpack-plugin/issues/880
    .plugin('html-sibling-chunks')
      .use(HtmlWebpackIncludeSiblingChunksPlugin);

  Object
    .keys(neutrino.options.mains)
    .forEach(key => {
      neutrino.config
        .entry(key)
          .add(neutrino.options.mains[key])
          .when(options.html, () => {
            neutrino.use(htmlTemplate, merge({
              pluginId: `html-${key}`,
              filename: `${key}.html`,
              // html-webpack-include-sibling-chunks-plugin dynamically updates this to
              // include the runtime chunk and any chunks generated by splitChunks.
              chunks: [key]
            }, options.html));
          });
    });

  neutrino.config
    .mode(process.env.NODE_ENV === 'production' ? 'production' : 'development')
    .optimization
      .minimize(options.minify.source)
      .splitChunks({
        // By default SplitChunksPlugin only splits out the async chunks (to avoid the
        // ever-changing file list breaking users who don't auto-generate their HTML):
        // https://webpack.js.org/plugins/split-chunks-plugin/#optimization-splitchunks-chunks-all
        // https://github.com/webpack/webpack/issues/7064
        chunks: 'all',
        // By default the generated files use names that reference the chunk names, eg:
        // `vendors~index~page2.b694ee990c08e6be6a33.js`. Setting to `false` causes them to
        // use the chunk ID instead (eg `1.ceddedc0defa56bec89f.js`), which prevents cache-
        // busting when a new page is added with the same shared vendor dependencies.
        name: process.env.NODE_ENV !== 'production'
      })
      // Create a separate chunk for the webpack runtime, so it can be cached separately
      // from the more frequently-changing entrypoint chunks.
      .runtimeChunk('single')
      .end()
    .when(options.style, () => neutrino.use(styleLoader, options.style))
    .when(options.font, () => neutrino.use(fontLoader, options.font))
    .when(options.image, () => neutrino.use(imageLoader, options.image))
    .target('web')
    .context(neutrino.options.root)
    .output
      .path(neutrino.options.output)
      .publicPath(options.publicPath)
      .filename('[name].js')
      .chunkFilename('[name].[chunkhash].js')
      .end()
    .resolve
      .modules
        .add('node_modules')
        .add(neutrino.options.node_modules)
        .add(MODULES)
        .when(__dirname.includes('neutrino-dev'), modules => {
          // Add monorepo node_modules to webpack module resolution
          modules.add(join(__dirname, '../../node_modules'));
          // Work around test failures when using Jest with Preact
          // https://github.com/mozilla-neutrino/neutrino-dev/issues/822
          modules.delete(neutrino.options.node_modules);
        })
        .end()
      .extensions
        .merge(neutrino.options.extensions.concat('json').map(ext => `.${ext}`))
        .end()
      .end()
    .resolveLoader
      .modules
        .add(neutrino.options.node_modules)
        .add(MODULES)
        .when(__dirname.includes('neutrino-dev'), modules => {
          // Add monorepo node_modules to webpack module resolution
          modules.add(join(__dirname, '../../node_modules'));
        })
        .end()
      .end()
    .node
      .set('Buffer', false)
      .set('fs', 'empty')
      .set('tls', 'empty')
      .end()
    .module
      .rule('worker')
        .test(neutrino.regexFromExtensions(neutrino.options.extensions.map(ext => `worker.${ext}`)))
        .use('worker')
          .loader(require.resolve('worker-loader'))
          .end()
        .end()
      .end()
    .when(neutrino.config.module.rules.has('lint'), () => {
      neutrino.use(loaderMerge('lint', 'eslint'), {
        envs: ['browser', 'commonjs']
      });
    })
    .when(process.env.NODE_ENV === 'development', config => config.devtool('cheap-module-eval-source-map'))
    .when(neutrino.options.command === 'start', (config) => {
      neutrino.use(devServer, options.devServer);
      config.when(options.hot, () => {
        neutrino.use(hot);
        config.when(options.hotEntries, (config) => {
          const protocol = config.devServer.get('https') ? 'https' : 'http';
          const url = `${protocol}://${config.devServer.get('public')}`;

          Object
            .keys(neutrino.options.mains)
            .forEach(key => {
              config
                .entry(key)
                  .batch(entry => {
                    options.hotEntries.forEach(hotEntry => entry.prepend(hotEntry));
                    entry
                      .prepend(require.resolve('webpack/hot/dev-server'))
                      .prepend(`${require.resolve('webpack-dev-server/client')}?${url}`);
                  });
            });
        });
      });
    })
    .when(process.env.NODE_ENV === 'production', (config) => {
      config
        .when(options.minify.style, () => neutrino.use(styleMinify, options.minify.style));
    })
    .when(neutrino.options.command === 'build', (config) => {
      config.when(options.clean, () => neutrino.use(clean, options.clean));

      if (options.manifest) {
        neutrino.config.plugin('manifest')
          .use(ManifestPlugin, [options.manifest]);
      }

      config.output.filename('[name].[chunkhash].js');
    });

  neutrino.on('prerun', () => {
    if (neutrino.config.entryPoints.has('vendor')) {
      return Promise.reject(
        new Error('Vendor chunks are now automatically generated. Remove the manual `vendor` entrypoint.')
      );
    }
    return Promise.resolve();
  })
};
